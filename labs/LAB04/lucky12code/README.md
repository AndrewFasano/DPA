LAB04: Custom Sanitizers
====

As the head of programming at **Lucky 12 Code**(TM), your bosses depend on  you to make sure the unlucky number 13 never shows up where it shouldn't be.
Unfortunately, another employee made a horrible mistake and a 13 was printed on a client's system.
But nobody knows where the mistake came from or how to fix it before this travesty happens again.

Being the great programmer you are, you've realized that what **Lucky 12 Code** needs is a suite of sanitizers to detect this error
and make sure nothing like it ever happens again.
You presented this plan to your management and they agreed to give you 90 minutes to build a suite of sanitizers and find the bug.

## System Setup
Pull the latest version of [dpa-containers](https://github.com/AndrewFasano/DPA-containers) and build the `llvm` container. Launch it with a shared directory to your host.
Download the provided sanitizers.tar.gz and extract it into the shared directory with your host.

## Sanitizer Specification
Before every call to puts, your `luckysan` sanitizer should should check if the buffer
contains a 13. If so, it should raise an error (e.g., print warning then exit or assert).

## Testing
Create your own C programs or use one of the provided ones to test your sanitizer.
**Lucky 12 Code** clients have reported seeing unlucky 13s be printed with the attached bug.c: can you figure out how?

## Performance Evaluation
After 90 minutes, you'll be called in to a meeting with the **Lucky 12 Code** management team. 
Your performance will be scored as follows:
2 points for the puts sanitizer, 1 point for the printf sanitizer, and 1 point for identifying any of the flaw(s) in bug.c.

# Instructions
The LLVM container has the following packages installed: llvm-dev, llvm, clang, cmake, build-essential and a few text editors.

After extracting the provided sanitizers directory, you should build the 3 provided sanitizers by going into
the `lucky12code/passes` directory and running:
```
# cmake .
# make
```

In each of the directories, `hello`, `helloputs`, and `luckysan` you should now have a `.so` file
which is a compiled version of the pass implemented in that directory's `.cpp` file.

Compile the provided hello world program to LLVM IR bytecode
```
# clang -O3 -emit-llvm ../helloworld.c -c -o helloworld.bc
```

For testing, you can run the bytecode directly using the `lli` utility:
```
# lli helloworld.bc
Hello world!
```

You can also translate the bytecode back to human-readable, LLVM IR in `hello.ll` with
```
# llvm-dis hello.bc -o hello.ll
# cat hello.ll
```

Now use the `opt` utility to a compiled pass over the bytecode. Note that it
requires an absolute path to the library you built and the argument is specified
in the corresponding `.cpp` file with the `Y` function.

```
# opt -load $(pwd)/hello/libhello.so -hello < hello.bc
# opt -load $(pwd)/hello/libhelloputs.so -helloputs < hello.bc
```

The `hello example doesn't modify the bytecode at all, it just prints some messages
while analyzing the bytecode. However, `helloputs` does modify the bytecode - so let's
save that output by passing the `-o` flag to `opt`:
```
# opt -load $(pwd)/helloputs/libhelloputs.so -helloputs -o hello2.bc < hello.bc
# lli hello2.bc
[HelloPuts] detected that there's about to be a puts of the string:
hello world
[HelloPuts] now let's keep going
hello world
```

### Lucky Sanitizer
The file `luckysan/luckysan.cpp` is largely a duplicate of `helloputs`, ready for you to build your own sanitizer.
You'll want to modify it to detect when a 13 is present in a buffer about to be printed with puts and, if so
print a warning (with some details about what's going on) and exit.

After you finish that, you should try to add support for printf sanitization. This one will be harder: the buffer being printed
by printf isn't simply available in an operand: you have to compute the buffer first (i.e., with sprintf), then check it.


## Resources

There are a lot of examples of working with the LLVM IR online. So long as you don't find an exact solution
for this lab, feel free to search for code examples and build your solution off of those. Be warned
that LLVM has changed significantly between versions. This lab is based off version 10. Thanks
to the type system, you're most likely to run into compile-time errors if you're trying to use
a function that's changed between versions.

The autogenerated doxygen code is very useful for figuring out what methods are available
for objects of various types. It's hard to search, but usually one of the first google results
for `llvm [classname]`.

### General
* https://github.com/llvm/llvm-project/blob/release/10.x/llvm/docs/ProgrammersManual.rst
* https://llvm.org/doxygen/

### LLVM Passes
* https://llvm.org/docs/WritingAnLLVMPass.html
* https://github.com/abenkhadra/llvm-pass-tutorial

### Build system / Out of tree passes:
* https://llvm.org/devmtg/2015-10/slides/GueltonGuinet-BuildingTestingDebuggingASimpleOutOfTreePass.pdf
* https://llvm.org/docs/CMake.html#cmake-out-of-source-pass
